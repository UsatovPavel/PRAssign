package team

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/UsatovPavel/PRAssign/internal/models"
	"github.com/UsatovPavel/PRAssign/internal/response"
	"github.com/UsatovPavel/PRAssign/internal/service"
)

type Handler struct {
	Service *service.TeamService
}

func NewHandler(s *service.TeamService) *Handler {
	return &Handler{Service: s}
}

func (h *Handler) Add(c *gin.Context) {
	var req AddTeamRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if _, err := h.Service.GetTeam(c, req.TeamName); err == nil {
		appErr := models.NewAppError(models.TeamExists, "team_name already exists")
		response.WriteAppError(c, appErr)
		return
	}

	members := make([]models.TeamMember, 0, len(req.Members))
	for _, m := range req.Members {
		members = append(members, models.TeamMember{
			UserID:   m.UserID,
			Username: m.Username,
			IsActive: m.IsActive,
		})
	}

	team := models.Team{
		TeamName: req.TeamName,
		Members:  members,
	}

	err := h.Service.CreateOrUpdateTeam(c, team)
	if err != nil {
		response.WriteAppError(c, err)
		return
	}

	c.JSON(http.StatusCreated, gin.H{"team": team})
}

func (h *Handler) Get(c *gin.Context) {
	teamName := c.Query("team_name")
	if teamName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "team_name required"})
		return
	}

	t, err := h.Service.GetTeam(c, teamName)
	if err != nil {
		response.WriteAppError(c, err)
		return
	}

	c.JSON(http.StatusOK, t)
}
package repository

import (
    "context"

    "github.com/UsatovPavel/PRAssign/internal/models"
)

type TeamPostgres struct {
    db *PostgresRepo
}

func NewTeamRepository(db *PostgresRepo) *TeamPostgres {
    return &TeamPostgres{db: db}
}

func (r *TeamPostgres) CreateOrUpdate(ctx context.Context, t models.Team) error {
    tx, err := r.db.Pool.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    _, err = tx.Exec(ctx, `INSERT INTO teams (team_name) VALUES ($1) ON CONFLICT DO NOTHING`, t.TeamName)
    if err != nil {
        return err
    }

    _, err = tx.Exec(ctx, `DELETE FROM users WHERE team_name = $1`, t.TeamName)
    if err != nil {
        return err
    }

    for _, m := range t.Members {
        _, err = tx.Exec(ctx,
            `INSERT INTO users (user_id, username, team_name, is_active)
             VALUES ($1,$2,$3,$4)
             ON CONFLICT (user_id) DO UPDATE
             SET username=EXCLUDED.username,
                 team_name=EXCLUDED.team_name,
                 is_active=EXCLUDED.is_active`,
            m.UserID, m.Username, t.TeamName, m.IsActive)
        if err != nil {
            return err
        }
    }

    return tx.Commit(ctx)
}

func (r *TeamPostgres) GetByName(ctx context.Context, name string) (*models.Team, error) {
    rows, err := r.db.Pool.Query(ctx,
        `SELECT user_id, username, is_active FROM users WHERE team_name = $1`,
        name)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var members []models.TeamMember

    for rows.Next() {
        var m models.TeamMember
        if err := rows.Scan(&m.UserID, &m.Username, &m.IsActive); err != nil {
            return nil, err
        }
        members = append(members, m)
    }

    if len(members) == 0 {
        return nil, models.NewAppError(models.NotFound, "team not found")
    }

    return &models.Team{TeamName: name, Members: members}, nil
}
package service

import (
	"context"

	"github.com/UsatovPavel/PRAssign/internal/models"
	"github.com/UsatovPavel/PRAssign/internal/repository"
)

type TeamService struct {
	repo repository.TeamRepository
}

func NewTeamService(repo repository.TeamRepository) *TeamService {
	return &TeamService{repo: repo}
}

func (s *TeamService) CreateOrUpdateTeam(ctx context.Context, team models.Team) error {
	return s.repo.CreateOrUpdate(ctx, team)
}

func (s *TeamService) GetTeam(ctx context.Context, name string) (*models.Team, error) {
	return s.repo.GetByName(ctx, name)
}
package response

import (
	"net/http"

	"github.com/UsatovPavel/PRAssign/internal/models"
	"github.com/gin-gonic/gin"
)

func WriteAppError(c *gin.Context, err error) {
	if app, ok := err.(*models.AppError); ok {
		c.JSON(codeToStatus(app.Code), gin.H{
			"error": gin.H{
				"code":    app.Code,
				"message": app.Message,
			},
		})
		return
	}

	c.JSON(http.StatusInternalServerError, gin.H{
		"error": gin.H{
			"code":    "INTERNAL",
			"message": err.Error(),
		},
	})
}

func WriteOK(c *gin.Context, payload any) {
	c.JSON(http.StatusOK, gin.H{
		"data": payload,
	})
}

func codeToStatus(code models.ErrorCode) int {
	switch code {
	case models.TeamExists,
		models.PRExists:
		return http.StatusConflict

	case models.NotFound:
		return http.StatusNotFound

	case models.NotAssigned,
		models.PRMerged,
		models.NoCandidate:
		return http.StatusConflict

	default:
		return http.StatusBadRequest
	}
}
